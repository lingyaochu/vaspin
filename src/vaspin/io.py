"""IO Module.

Contains functionality for reading and writing VASP files.
"""

from __future__ import annotations

import re
from json import JSONDecodeError, dumps, load, loads
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, List

import numpy as np

from vaspin.outcar import VaspOutcarParser
from vaspin.types import FloatArray, StrArray

if TYPE_CHECKING:
    from vaspin.incar.tags import Tag

from vaspin.utils.utils import createdir


def read_file(filepath: str, fallback: Callable[[str], str]) -> dict[str, Any]:
    """The general method to read a file

    The file should be a json file
    or a file can be converted to json format by fallback function.

    Args:
        filepath: Path to the file
        fallback: Function to convert file content to JSON format

    Returns:
        Dictionary containing file data

    Raises:
        FileNotFoundError: If the file does not exist
    """
    if not Path(filepath).exists():
        raise FileNotFoundError(f"File does not exist: {filepath}")

    try:
        with open(filepath, "r") as f:
            data = load(f)
    except JSONDecodeError:
        data = loads(fallback(filepath))

    return data


def read_poscar(posfile: str) -> dict[str, Any]:
    """Read POSCAR file or JSON file

    Args:
        posfile: Path to POSCAR file or JSON file

    Returns:
        Dictionary containing POSCAR data
    """
    return read_file(posfile, poscar_to_json)


def poscar_to_json(filepath: str) -> str:
    """Convert POSCAR file to JSON string format

    Args:
        filepath: Path to POSCAR file

    Returns:
        JSON formatted string

    Raises:
        ValueError: Invalid file format
    """
    try:
        with open(filepath, "r") as f:
            poscar_lines = f.readlines()
    except (IOError, ValueError) as e:
        raise ValueError(f"Cannot parse POSCAR file {filepath}: {e}") from e

    comment = poscar_lines[0].strip()
    lattice_coe = float(poscar_lines[1].strip())

    lattice = []
    for i in range(2, 5):
        lattice.append([float(x) for x in re.split(r"\s+", poscar_lines[i].strip())])

    species = [x.split("/")[0] for x in re.split(r"\s+", poscar_lines[5].strip())]
    atom_numbers = [int(x) for x in re.split(r"\s+", poscar_lines[6].strip())]
    coor_type = poscar_lines[7].strip()
    total_atoms = sum(atom_numbers)

    coordinates = []
    for i in range(8, 8 + total_atoms):
        coordinates.append(
            [float(x) for x in re.split(r"\s+", poscar_lines[i].strip())[:3]]
        )

    data = {
        "comment": comment,
        "coe": lattice_coe,
        "lattice": lattice,
        "species": species,
        "number": atom_numbers,
        "coortype": coor_type,
        "coordinate": coordinates,
    }
    return dumps(data, indent=None)


def write_poscar(
    lattice: FloatArray,
    atoms: StrArray,
    coor_frac: FloatArray,
    directory: str = ".",
    comment: str = "generated by mother python",
    name: str = "POSCAR",
) -> None:
    """Write data to POSCAR file

    Args:
        lattice: Lattice data
        atoms: the atom list data
        coor_frac: Fractional coordinate data
        directory: Directory to write file to, defaults to current directory
        comment: Description in first line of POSCAR file
        name: Name of POSCAR file, defaults to POSCAR

    Returns:
        None
    """
    # Convert lattice data to string
    lattice_str = ""
    for i in range(3):
        lattice_str += (
            f" {lattice[i][0]:20.16f} {lattice[i][1]:20.16f} {lattice[i][2]:20.16f}\n"
        )

    # Convert coordinate data to string
    coor_str = ""
    for i in range(len(coor_frac)):
        coor_str += (
            f" {coor_frac[i][0]:20.16f}"
            + f" {coor_frac[i][1]:20.16f}"
            + f" {coor_frac[i][2]:20.16f}\n"
        )

    # Convert atom list data to string
    unique_atoms = np.unique(atoms)
    element_str = ""
    for atom in unique_atoms:
        element_str += f" {atom}"

    # Convert atom count data to string
    number_str = ""
    atoms_list = list(atoms)  # Ensure species is a Python list
    for atom in unique_atoms:
        number_str += f" {atoms_list.count(atom)}"

    # Write to file
    createdir(directory)
    with open(directory + f"/{name}", "w") as f:
        f.write(comment + "\n")
        f.write(" 1.0\n")
        f.write(lattice_str)
        f.write(element_str + "\n")
        f.write(number_str + "\n")
        f.write("Direct" + "\n")
        f.write(coor_str)


def read_phonon(phononfile: str) -> dict[str, List[float]]:
    """Read phonon data from files

    Args:
        phononfile: Path to the file, either a OUTCAR of a phonon.json

    Returns:
        the phonon data as a dictionary with keys:
            - "frequencies": List of frequencies in THz
            - "eigenmodes": List of eigenmodes as 2D List
    """
    return read_file(phononfile, phonon_to_json)


def phonon_to_json(filepath: str) -> str:
    """Convert phonon info to JSON string format

    Args:
        filepath: Path to OUTCAR file

    Returns:
        JSON formatted string
    """
    pho_parser = VaspOutcarParser(filepath)
    pho_parser.set_handlers(["N ions", "Phonon"])
    pho_parser.parse()
    phonon_dict = pho_parser.phonon

    return dumps(phonon_dict, indent=None)


def read_incar(incarfile: str) -> dict[str, Any]:
    """Read INCAR file or JSON file

    Args:
        incarfile: Path to INCAR file or JSON file

    Returns:
        Dictionary containing INCAR data
    """
    return read_file(incarfile, incar_to_json)


def incar_to_json(filepath: str | Path) -> str:
    """Convert INCAR file to JSON string format

    Args:
        filepath: Path to INCAR file

    Returns:
        JSON formatted string
    """
    try:
        with open(filepath, "r") as f:
            incar_lines = f.readlines()
    except (IOError, ValueError) as e:
        raise ValueError(f"Cannot parse INCAR file {filepath}: {e}") from e

    incar_dict = {}
    for line in incar_lines:
        line = line.strip()
        if not line or line.startswith("#") or line.startswith("!"):
            continue
        if "=" not in line:
            raise ValueError(f"Invalid INCAR line:{line}")
        key_and_value = re.split("[#!]", line, maxsplit=1)[0]
        key, value = key_and_value.split("=")
        key = key.strip()
        value = _value_convert(value.strip())
        incar_dict[key] = value
    return dumps(incar_dict, indent=None)


def _value_convert(value: str) -> str | float | int | bool:
    """Convert string value to appropriate type.

    Args:
        value: The string value to convert.

    Returns:
        The converted value as str, float, int, or bool.
    """
    ture_prefix = ("T", ".T", "t", ".t")
    false_prefix = ("F", ".F", "f", ".f")
    if value.startswith(ture_prefix):
        return True
    elif value.startswith(false_prefix):
        return False

    for converter in (int, float):
        try:
            return converter(value)
        except ValueError:
            continue
    return value


def write_incar(tags: list[Tag], directory: str = ".", name: str = "INCAR") -> None:
    """Write INCAR tags to a file.

    Args:
        tags: List of Tag objects to write to the INCAR file.
        directory: Directory to write the INCAR file to, defaults to current directory.
        name: Name of the INCAR file, defaults to "INCAR".
    """
    file_path = Path(directory) / name
    createdir(directory)

    incar_string = "\n".join(str(tag) for tag in tags)
    with open(file_path, "w") as f:
        f.write(incar_string)
