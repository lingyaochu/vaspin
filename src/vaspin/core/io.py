"""IO Module.

Contains functionality for reading and writing VASP files.
"""

import re
from json import JSONDecodeError, dumps, load, loads
from pathlib import Path
from typing import Any, Callable, List

import numpy as np

from vaspin.core.outcar import VaspOutcarParser
from vaspin.types.array import FloatArray, StrArray


def read_file(filepath: str, fallback: Callable[[str], str]) -> dict[str, Any]:
    """The general method to read a file

    The file should be a json file
    or a file can be converted to json format by fallback function.

    Args:
        filepath: Path to the file
        fallback: Function to convert file content to JSON format

    Returns:
        Dictionary containing file data

    Raises:
        FileNotFoundError: If the file does not exist
    """
    if not Path(filepath).exists():
        raise FileNotFoundError(f"File does not exist: {filepath}")

    try:
        with open(filepath, "r") as f:
            data = load(f)
    except JSONDecodeError:
        data = loads(fallback(filepath))

    return data


def read_poscar(posfile: str) -> dict[str, Any]:
    """Read POSCAR file or JSON file

    Args:
        posfile: Path to POSCAR file or JSON file

    Returns:
        Dictionary containing POSCAR data
    """
    return read_file(posfile, poscar_to_json)


def poscar_to_json(filepath: str) -> str:
    """Convert POSCAR file to JSON string format

    Args:
        filepath: Path to POSCAR file

    Returns:
        JSON formatted string

    Raises:
        ValueError: Invalid file format
    """
    try:
        with open(filepath, "r") as f:
            # read comment
            comment = f.readline().strip()

            # Read lattice constant and lattice vectors
            coe = float(f.readline().strip())
            lattice = []
            for _ in range(3):
                lattice.append(
                    [float(x) for x in re.split(r"\s+", f.readline().strip())]
                )

            # Read atom types and quantities
            species = [x.split("/")[0] for x in re.split(r"\s+", f.readline().strip())]
            atom_numbers = [int(x) for x in re.split(r"\s+", f.readline().strip())]

            # Read coordinate type and coordinates
            coor_type = f.readline().strip()
            total_atoms = sum(atom_numbers)
            coordinates = []
            for _ in range(total_atoms):
                coordinates.append(
                    [float(x) for x in re.split(r"\s+", f.readline().strip())[:3]]
                )

            # Build data dictionary
            data = {
                "comment": comment,
                "coe": coe,
                "lattice": lattice,
                "species": species,
                "number": atom_numbers,
                "coortype": coor_type,
                "coordinate": coordinates,
            }

            return dumps(data, indent=None)
    except (IOError, ValueError) as e:
        raise ValueError(f"Cannot parse POSCAR file {filepath}: {e}") from e


def write_poscar(
    lattice: FloatArray,
    atoms: StrArray,
    coor_frac: FloatArray,
    directory: str = ".",
    comment: str = "generated by mother python",
    name: str = "POSCAR",
) -> None:
    """Write data to POSCAR file

    Args:
        lattice: Lattice data
        atoms: the atom list data
        coor_frac: Fractional coordinate data
        directory: Directory to write file to, defaults to current directory
        comment: Description in first line of POSCAR file
        name: Name of POSCAR file, defaults to POSCAR

    Returns:
        None
    """
    from ..utils.utils import clean

    # Convert lattice data to string
    lattice_str = ""
    for i in range(3):
        lattice_str += (
            f" {lattice[i][0]:20.16f} {lattice[i][1]:20.16f} {lattice[i][2]:20.16f}\n"
        )

    # Convert coordinate data to string
    coor_str = ""
    for i in range(len(coor_frac)):
        coor_str += (
            f" {coor_frac[i][0]:20.16f}"
            + f" {coor_frac[i][1]:20.16f}"
            + f" {coor_frac[i][2]:20.16f}\n"
        )

    # Convert atom list data to string
    unique_atoms = np.unique(atoms)
    element_str = ""
    for atom in unique_atoms:
        element_str += f" {atom}"

    # Convert atom count data to string
    number_str = ""
    atoms_list = list(atoms)  # Ensure species is a Python list
    for atom in unique_atoms:
        number_str += f" {atoms_list.count(atom)}"

    # Write to file
    clean(directory)
    with open(directory + f"/{name}", "w") as f:
        f.write(comment + "\n")
        f.write(" 1.0\n")
        f.write(lattice_str)
        f.write(element_str + "\n")
        f.write(number_str + "\n")
        f.write("Direct" + "\n")
        f.write(coor_str)


def read_phonon(phononfile: str) -> dict[str, List[float]]:
    """Read phonon data from files

    Args:
        phononfile: Path to the file, either a OUTCAR of a phonon.json

    Returns:
        the phonon data as a dictionary with keys:
            - "frequencies": List of frequencies in THz
            - "eigenmodes": List of eigenmodes as 2D List
    """
    return read_file(phononfile, phonon_to_json)


def phonon_to_json(filepath: str) -> str:
    """Convert phonon info to JSON string format

    Args:
        filepath: Path to OUTCAR file

    Returns:
        JSON formatted string
    """
    pho_parser = VaspOutcarParser(filepath)
    pho_parser.set_handlers(["N ions", "Phonon"])
    pho_parser.parse()
    phonon_dict = pho_parser.phonon

    return dumps(phonon_dict, indent=None)
